---
layout: page
title: "software Eng. lecture note"
permalink: /docs/softwareEng2025
---

# ソフトウェア工学まとめ

ソフトウェア工学はソフトウェア・エンジニアリングの基礎知識の理解及び実務的なスキルの習得を目標とする講義である

## ソフトウェア工学概論

### ソフトウェアの定義

1. 実行されることによって必要な特性、機能、性能を提供する命令語群（コンピュータプログラム）

2. プログラムが適切に情報を扱うことを可能とするデータ構造

3. プログラムの操作や使用法を記述した情報 

### ソフトウェアの特徴

- 新しい環境や技術のニーズを満たすよう適応しなければならない
- 新しいビジネス要求を実現するために強化されなければならない
- より近代的なシステムやデータベースと相互運用するため拡張されなければならない
- 進化し続ける環境で実行可能となるよう、再構築されなければならない

### プラクティスの本質

1. 問題を理解する（コミュニケーションと分析
2. 解決策を計画する（モデリングとソフトウェア設計
3. 計画を実行に移す（コード実装
4. 結果が正しいことを理解する（テストと品質保証

### Hookerの7原則

1. システムが存在する唯一の理由
    - システムはユーザーに価値を提供するためにある
2. シンプルにしておけ！（KISS: Keep It Simple, Stupid!）
    - すべての設計は可能な限りシンプルであるべき
3. ビジョンを持ち続けよ
    - ソフトウェアプロジェクトの成功には明確なビジョンが不可欠である
4. あなたの作ったものを他の人が使用する
    - あなたのやっていることを他人が理解しなければならないということを常に考えながら仕様を決め、設計し、ドキュメントを書き、実装するべきである。
5. 未来へオープンであれ
    - コンピュータ環境の仕様変更に対応すべく、一般的な問題を解決するシステムを構築して、可能な限り多くの選択肢を与えられるよう準備しておく。
6. 再利用に先駆けて計画せよ
    - コストを低減し、再利用するコンポーネントとそれを取り込むシステムの両方の価値を高める。
7. 考えよ！
    - 行動を起こす前に簡潔明瞭な考えをもつことは、必ずと行ってよいほどよい結果を生む。

### ソフトウェアの必要性

1. 大規模化と複雑さ

ソフトウェアなしでは社会がまわらない

- ソフトウェアを効率よく開発し、メンテナンスする必要がある
- 効率と品質の両方が求められる
- 部品化、オブジェクト化が有効

2. IT人材の不足

- ソフトウェアの需要に対してIT人材が追いついていない量的問題

- ソフトウェアを効率的に開発・管理することのできる人材が少ない質的問題

3. 社会性と求められるミッション

ライフライン・インフラストラクチャーとしてのソフトウェアが増加

不測の事態に対応した事業・サービスの継続が求められる

4. 不確実性の増大

- ソフトウェアの利用の変化・多様化
- ニーズに対応したソフトウェアの開発

### プログラミングの稼働期間とアップグレードの重要性

- 想定内の保守管理対応
    - バージョン更改
    - コード管理

- 想定外の保守管理対応
    - トラブル
    - ユーザー需要
    - 新技術
    - チーム管理

### Hyrumの法則

あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。
作られたシステムが持つあらゆる観察可能 （observable）な挙動に関して、それに依存するユーザーが出てくるものである。

## ソフトウェアライフサイクル

ソフトウェアはニーズの発生やビジネス上あるいはシステム上の要求を具現化するための企画や計画を行う際に発生する

1. 要件定義
    - 実現する機能と実現しない機能を明確にする
    - 企業によってはテンプレート化されている

2. 設計
    - 要件定義書から設計書へと移り変わる
    - クラスやモジュールなどコーディングができるレベルの仕様書に落とし込む
    - WBSなどを使う

3. 制作
    - 設計書したがってシステムを構築する
    - 自社開発による内製と外部委託による調達がある
    - 賃金の安い海外企業に外部委託するオフショア開発もある

4. テストとデバッグ
    - バグの全くないソフトウェアはないと考えるべき
    - 可能な限りテストで網羅し、早期にバグを発見・対処するべき
    - すべてをテストすることは工数上不可能に近いのでどの程度テストするかは決める必要がある

5. 運用・保守
    - ソフトウェア以外の要因も考慮する必要がある
    - 開発者はプロジェクトから離れている可能性がある

複数人でのソフトウェア開発ではドキュメンテーションを用いることが多く、非同期のコミュニケーションが重要となる。IT技術はほとんどが海外で作られるためドキュメントやエラーメッセージなどは基本的に英語である。

## ソフトウェア分析

ソフトウェアを見える化するための手法

- ソフトウェアの物量に関する分析
- ソフトウェアの実行性能に関する分析
- ソフトウェアのの開発工数に関する分析
- ソフトウェアの品質に関する分析

### ソフトウェアの評価

1. コードの物量(ステップ数)

    (例)C言語換算におけるソースコード行数
    複数言語が入り混じっている場合は換算する必要がある

2. オブジェクト容量

    組み込み型ソフトウェアはサイズが小さいほど良い

3. バグ発生率

    1ステップ数（改行を除いたコード行数）あたりの発生バグ数を示す

    (例)100ステップのソフトウェアに100のテストを実施し10件のバグ発生
    `バグ発生率1 = 10(件) / 100(ステップ) = 0.1(件/ステップ)`

    追加で50のテストを実施し、5件のバグ発生
    `バグ発生率2 = 15(件) / 100(ステップ) = 0.15(件/ステップ)`

    バグ発生率はソフトウェア品質評価の1指標となる

4. ファンクションポイント法

    ソフトウェア開発における機能の計測と工数見積もりを行うための手法

    `FP値 = 基準値 × (0.65 + 調整値 / 100)`

    `原価 = FP値 × 作業単価 × 換算値`

## 開発プロセス

- ウォーターフォール型開発プロセス
要件定義、設計、製作、単体テスト、組み合わせテストなどの手順を順番に行う。進捗管理が容易で成果物が明確という特徴がある。

- スパイラルモデル
プログラムを小さなフェーズに分割して、フェーズごとにプロトタイプによるデモンストレーションを行う。ただし、プロトタイプ作成に想定外の作業量が発生するリスクあり。

- 反復型開発プロセス
ソフトウェアを機能分割し「反復」という単位で管理することで部分的に完成・納品され、顧客の要求を取り入れやすいメリットがある。

- アジャイルプロセス
チームを組んで「要件定義→設計→開発→テスト→リリース(運用)」といった開発工程を、1つの機能を単位とした小さいサイクルで繰り返す。イテレーションと呼ばれる小さなサイクルを回すことで常に機能ごとのリリースを行い、素早い開発が可能となる。

## コーディング

コードは書くよりも読まれることのほうが多いため他人が読んでも読みやすいコードを目指すべきである
- 1行の長さは大体79文字以内にする
- 行を継続する場合は折り返された要素を縦に揃える(Hanging indentation)
- 1レベルインデントを使う
- 演算子の前後にスペースを前後に一つずつ空ける
- 文を重ねない
- 演算子の位置を揃える
- 命名規則

|項目|命名規則|
|---|---|
|パッケージ|すべて小文字の短い名前、アンダースコアは使わない|
|モジュール|すべて小文字の短い名前、アンダースコアで区切ってもよい|
|クラス|CapWords方式（単語の先頭を大文字にする）|
|関数|すべて小文字の短い名前、必要に応じてアンダースコアで区切る|
|変数|すべて小文字の短い名前、必要に応じて単語をアンダースコアで区切る|
|定数|すべて大文字の短い名前、単語をアンダースコアで区切る|
|1文字変数|l（小文字のL）やO（大文字のオー）など、混乱を招く可能性のある文字は使用しない|

- UTF-8以外のエンコーディングは可能な限り使わない
- ASCII文字以外の使用を極力避ける

コードチェックツール(Linter)による自動整形を使うことで自動化できる

## バージョン管理

バージョン管理とは、ファイルを「誰が」「いつ」「どのように」変更したかを管理するためのものである。ファイルの変更情報が管理されていれば多数のメンバーとも共同でコード開発ができる。集中管理型にSubversion、分散管理型にGitがある。

- 集中管理型
リモートリポジトリのみがバージョン管理の対象であり、同時編集をするとコンフリクトが発生しやすい

- 分散管理型
リモートリポジトリへのアクセス頻度が低く障害に頑健であり、ローカルでもバージョン管理が可能

## CI/CD

### Continuous Integration (CI)

- コード変更を共有リポジトリに頻繁に統合するプロセス
- 自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能
- CIの自動化により開発のスムーズな進行を促進

### Continuous Delivery (CD)

- コード変更をテスト環境や本番環境に自動的にデプロイするプロセス
- 自動デプロイメントを組み込み、手動操作によるデプロイの必要性を排除
- CDによりユーザーフィードバックを迅速に反映可能

### CI/CDパイプラインの実行フロー

1. コードの変更をトリガーにワークフロー(GitHub Actionsなど)を起動
2. ソースコードをコンパイル
3. 自動テストを実行
4. テスト済みのコードを本番環境にデプロイ
5. デプロイされたアプリケーションの動作確認
6. 本番環境での継続的な監視

## GitHub Pages

GitHubにあるリモートリポジトリの内容をWebページとして公開することができる

- ページの更改はCI/CDにより自動化できる
- Jekyllを使用することでマークダウンファイルを自動でHTMLに変換することができる(開発者はマークダウンファイルを作成すればよい)
